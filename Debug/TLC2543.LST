C51 COMPILER V9.00   TLC2543                                                               07/28/2016 13:53:29 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TLC2543
OBJECT MODULE PLACED IN TLC2543.OBJ
COMPILER INVOKED BY: E:\Keil\C51\Bin\C51.exe TLC2543.c DB OE INCDIR(E:\Keil\C51\INC;E:\Keil\C51\INC)

line level    source

   1          #include"stc12c5a.h"
   2          #include"intrins.h"
   3          #include"tlc2543.h"  //ad
   4          #include"main.h"    //主要注释
   5          #include"st7565.c"  //12864
   6          
   7          #include "x9103.c"
   8          
   9          //#include "lcd_drive.c"
  10          //#include "gui.c"
  11          
  12          /****************************************
  13          *五路AD： 分别采样10次，
  14          *输入电压、输出电压、输出电流（1，2 ）、负载识别
  15          *
  16          *   
  17          *
  18          ********************************************/
  19          unsigned int xdata AD_[5][10] = 0;
  20          double temp[5] = 0;
  21          uint  AD_num[5]=0,e = 0;
  22          uchar aps=0,adtime=0,ad_chunnel = 0,showts = 0;
  23          
  24          uchar ocp = 30;//过流保护
  25          
  26          
  27          void delay(uint t)
  28          {
  29   1              while(t--);
  30   1      }
  31          
  32          /*
  33          void InitSPI()
  34          {
  35                  AUXR1 = 0X00;
  36              SPDAT = 0;      //initial SPI data
  37              SPSTAT = SPIF | WCOL;    //SPI状态寄存器
  38              SPCTL = SPEN | MSTR | SPSPEEDH;        //SPI控制寄存器
  39          }
  40          
  41          uchar WriteByte(uchar temp)
  42          {
  43          //      SPCTL = SPEN | MSTR | SPSPEEDH;        //SPI控制寄存器
  44                  SPDAT = temp;
  45              while (!(SPSTAT & SPIF));   //wait send complete
  46              SPSTAT = SPIF | WCOL;       //spi状态寄存器
  47                  delay(20);
  48                  return SPDAT;
  49          }
  50          
  51          */
  52          /*
  53          uint revAD(uchar chunnel)
  54          {
  55                  uint doc = 0 , a = 0, b = 0;
C51 COMPILER V9.00   TLC2543                                                               07/28/2016 13:53:29 PAGE 2   

  56                  ad_cs = 0;
  57                  a = WriteByte( (chunnel<<4) | 0x0c );
  58                  b = WriteByte(0);
  59                  ad_cs = 1;
  60                  a <<= 8;
  61                  doc = a | b;
  62                  doc >>= 4;
  63                  return doc;
  64          }*/
  65          
  66          uint readAD(uchar chunnel)
  67          {
  68   1              uchar i = 0,dout = ad_chunnel_select[chunnel];
  69   1              uint din=0;
  70   1              _nop_();
  71   1              _nop_();
  72   1              _nop_();
  73   1              ad_cs = 0;
  74   1      //      ad_clock = 0;
  75   1      
  76   1              for(i = 0;i < 16;i++)
  77   1              {
  78   2                      ad_clock = 1;
  79   2                      if(dout & 0x80)ad_in = 1;
  80   2                      else ad_in = 0;
  81   2                      dout <<=1;
  82   2                      ad_clock = 0;
  83   2                      _nop_();
  84   2              }
  85   1              for(i=0;i<16;i++)
  86   1              {
  87   2                      
  88   2                      if(ad_out == 1)din |= 0x0001;
  89   2                      ad_clock = 1;
  90   2                      din <<= 1;
  91   2                      ad_clock = 0;
  92   2                      _nop_();
  93   2              }
  94   1              ad_cs = 1;
  95   1              din >>= 4;
  96   1              return (din);
  97   1      }
  98          
  99          
 100          
 101          /*
 102          double KalmanFilter(const double ResrcData,
 103                                                  double ProcessNiose_Q,
 104                                                  double MeasureNoise_R)
 105          {
 106          double R = MeasureNoise_R;
 107          double Q = ProcessNiose_Q;
 108          
 109              static double x_last;
 110          
 111              double x_mid = x_last;
 112              double x_now;
 113          
 114              static double p_last;
 115          
 116              double p_mid ;
 117              double p_now;
C51 COMPILER V9.00   TLC2543                                                               07/28/2016 13:53:29 PAGE 3   

 118              double kg;        
 119          
 120              x_mid=x_last; //x_last=x(k-1|k-1),x_mid=x(k|k-1)
 121              p_mid=p_last+Q; //p_mid=p(k|k-1),p_last=p(k-1|k-1),Q=??
 122              kg=p_mid/(p_mid+R); //kg?kalman filter,R???
 123              x_now=x_mid+kg*(ResrcData-x_mid);
 124                      
 125              p_now=(1-kg)*p_mid;  
 126          
 127              p_last = p_now; 
 128              x_last = x_now; 
 129          
 130              return x_now;
 131          }
 132          */
 133          
 134          
 135          void bubble(unsigned int* array,uchar len)
 136          {
 137   1              uchar i = 0,j = 0;
 138   1              unsigned int tmp;
 139   1              for(i = 0;i < len;i++)
 140   1                  {
 141   2                      for(j=0;j < len;j++)
 142   2                      {
 143   3                          if(array[j] > array[i])
 144   3                          {
 145   4                              tmp = array[j];
 146   4                              array[j] = array[i];
 147   4                              array[i] = tmp;
 148   4                          }
 149   3                      } 
 150   2                  }
 151   1      }
 152          
 153          
 154          double Average(unsigned int *array,unsigned char index,unsigned char len)
 155          {
 156   1        double aver=0,count=index;
 157   1       int i;
 158   1       for(i=index;i<(len-index);i++)
 159   1       {
 160   2         aver+=array[i]; 
 161   2        aver/=(double)(count++==index?1:2); 
 162   2       }
 163   1       return aver;
 164   1      }
 165          
 166          
 167          void ad_show()
 168          {
 169   1      
 170   1              /**********************输入电压**********************************/
 171   1                      lcd_putnumstr(32,0,0,AD_num[0]/10000);
 172   1                      Lcd12864_Write16CnCHAR(40,0,0,".");
 173   1                      lcd_putnumstr(48,0,0,AD_num[0]%10000/1000);
 174   1                      lcd_putnumstr(56,0,0,AD_num[0]%10000%1000/100);
 175   1      //              lcd_putnumstr(64,0,0,AD_num[0]%10000%1000%100/10);
 176   1      //              lcd_putnumstr(72,0,0,AD_num[0]%10000%1000%100%10);
 177   1      
 178   1          /******************************过流保护****************************/
 179   1                                      lcd_putnumstr(104,0,0,ocp/10);
C51 COMPILER V9.00   TLC2543                                                               07/28/2016 13:53:29 PAGE 4   

 180   1                      Lcd12864_Write16CnCHAR(112,0,0,".");
 181   1                      lcd_putnumstr(120,0,0,ocp%10);
 182   1      //              lcd_putnumstr(120,0,0,AD_num[1]%10000%1000/100);
 183   1      //              lcd_putnumstr(112,0,0,AD_num[1]%10000%1000%100/10);
 184   1      //              lcd_putnumstr(120,0,0,AD_num[1]%10000%1000%100%10);
 185   1      
 186   1          /******************************输出电压****************************/
 187   1                                      lcd_putnumstr(40,2,0,AD_num[2]/10000);
 188   1                      Lcd12864_Write16CnCHAR(48,2,0,".");
 189   1                      lcd_putnumstr(56,2,0,AD_num[2]%10000/1000);
 190   1                      lcd_putnumstr(64,2,0,AD_num[2]%10000%1000/100);
 191   1      //              lcd_putnumstr(64,2,0,AD_num[2]%10000%1000%100/10);
 192   1      //              lcd_putnumstr(72,2,0,AD_num[2]%10000%1000%100%10);
 193   1      
 194   1          /******************************输出电流****************************/
 195   1                                      lcd_putnumstr(40,4,0,AD_num[3]/10000);
 196   1                      Lcd12864_Write16CnCHAR(48,4,0,".");
 197   1                      lcd_putnumstr(56,4,0,AD_num[3]%10000/1000);
 198   1                      lcd_putnumstr(64,4,0,AD_num[3]%10000%1000/100);
 199   1      //              lcd_putnumstr(112,2,0,AD_num[3]%10000%1000%100/10);
 200   1      //              lcd_putnumstr(120,2,0,AD_num[3]%10000%1000%100%10);
 201   1      
 202   1      }
 203          
 204          uchar x9c = 0;
 205          
 206          
 207          uint xpd(double value)
 208          {
 209   1              static const Vcc = 5.15 , R1 = 524;
 210   1              double tmp = (Vcc - value)/R1;
 211   1              double R2 = value / tmp;
 212   1              return ((R2 + 50)/10);
 213   1      }
 214          
 215          
 216          void zd1() interrupt 1
 217          {
 218   1              unsigned char i=0;
 219   1              TH0 = (65536-200)/256;
 220   1              TL0 = (65536-200)%256;
 221   1              e++;
 222   1              adtime++;
 223   1              if(adtime == 10)//2.0ms 采样一次  分别四路
 224   1              {
 225   2                      adtime = 0;
 226   2                      AD_[ad_chunnel][aps] = readAD(ad_chunnel);
 227   2                      ad_chunnel++;
 228   2              }
 229   1              if(ad_chunnel == 5){ad_chunnel = 0;aps++;}
 230   1      
 231   1              if(aps == 10) //100ms 计算一次
 232   1              {
 233   2                      aps = 0;
 234   2                      for(i = 0;i < 5;i++) 
 235   2                      {
 236   3                              bubble(AD_[i],10);            //冒泡
 237   3                              temp[i]  = Average(AD_[i],1,9); //平均值
 238   3                              temp[i] = (temp[i] * addTcl2543) *10000;                
 239   3                      }
 240   2              }
 241   1              if(e == 1000) //1s 输出一次
C51 COMPILER V9.00   TLC2543                                                               07/28/2016 13:53:29 PAGE 5   

 242   1              {
 243   2                      e = 0;
 244   2                      AD_num[showts] = temp[showts];
 245   2                      showts++;
 246   2                      if(showts == 5)showts=0;
 247   2              }
 248   1      }
 249          
 250          void main(void)
 251          {
 252   1      
 253   1              TMOD = 0x01;
 254   1              TH0 = (65536-250)/256;
 255   1              TL0 = (65536-250)%256;
 256   1              ET0 = 1;
 257   1              TR0 = 1;
 258   1              EA = 1;
 259   1              x9cInit();  //
 260   1              Lcd12864_Init();
 261   1              Lcd12864_ClearScreen(0x00);//清屏
 262   1      //      Lcd12864_Write16CnCHAR(0,0,0,"Welcome to ");
 263   1      //      Lcd12864_Write16CnCHAR(0,2,0," using the AD/C. ");
 264   1              Lcd12864_Write16CnCHAR(0,0,0,"inV:     OCP:");
 265   1              Lcd12864_Write16CnCHAR(0,2,0,"outV:");
 266   1              Lcd12864_Write16CnCHAR(0,4,0,"outA:");
 267   1      
 268   1      
 269   1              while(1)
 270   1              {
 271   2                      ad_show();
 272   2              }
 273   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2725    ----
   CONSTANT SIZE    =   1708    ----
   XDATA SIZE       =    100    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44      63
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.00   TLC2543                                                               07/29/2016 10:33:52 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TLC2543
OBJECT MODULE PLACED IN TLC2543.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE TLC2543.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include"stc12c5a.h"
   2          #include"intrins.h"
   3          #include"tlc2543.h"  //ad
   4          #include"main.h"    //主要注释
   5          #include"st7565.c"  //12864
   6          
   7          #include "x9103.c"
   8          
   9          /****************************************
  10          *五路AD： 分别采样10次，
  11          *IN0:输入电压、
  12          *IN1:输出电压、
  13          *IN2、IN3:输出电流（1，2 ）、
  14          *IN4:负载识别
  15          ********************************************/
  16          unsigned int xdata AD_[5][10] = 0;
  17          double temp[5] = 0;
  18          uint  AD_num[5]=0,e = 0;
  19          uchar aps=0,adtime=0,ad_chunnel = 0,showts = 0;
  20          
  21          uchar ocp = 30;//过流保护  一次0.1
  22          
  23          bit d2buff = 0;
  24          
  25          void delay(uint t)
  26          {
  27   1              while(t--);
  28   1      }
  29          
  30          /*  硬件SPI
  31          void InitSPI()
  32          {
  33                  AUXR1 = 0X00;
  34              SPDAT = 0;      //initial SPI data
  35              SPSTAT = SPIF | WCOL;    //SPI状态寄存器
  36              SPCTL = SPEN | MSTR | SPSPEEDH;        //SPI控制寄存器
  37          }
  38          uchar WriteByte(uchar temp)
  39          {
  40          //      SPCTL = SPEN | MSTR | SPSPEEDH;        //SPI控制寄存器
  41                  SPDAT = temp;
  42              while (!(SPSTAT & SPIF));   //wait send complete
  43              SPSTAT = SPIF | WCOL;       //spi状态寄存器
  44                  delay(20);
  45                  return SPDAT;
  46          }
  47          */
  48          /*
  49          uint revAD(uchar chunnel)
  50          {
  51                  uint doc = 0 , a = 0, b = 0;
  52                  ad_cs = 0;
  53                  a = WriteByte( (chunnel<<4) | 0x0c );
  54                  b = WriteByte(0);
  55                  ad_cs = 1;
C51 COMPILER V9.00   TLC2543                                                               07/29/2016 10:33:52 PAGE 2   

  56                  a <<= 8;
  57                  doc = a | b;
  58                  doc >>= 4;
  59                  return doc;
  60          }*/
  61          
  62          /*************软件模拟SPI*****************************/
  63          uint readAD(uchar chunnel)
  64          {
  65   1              uchar i = 0,dout = ad_chunnel_select[chunnel];
  66   1              uint din=0;
  67   1              _nop_();
  68   1              _nop_();
  69   1              _nop_();
  70   1              ad_cs = 0;
  71   1      //      ad_clock = 0;
  72   1      
  73   1              for(i = 0;i < 16;i++)
  74   1              {
  75   2                      ad_clock = 1;
  76   2                      if(dout & 0x80)ad_in = 1;
  77   2                      else ad_in = 0;
  78   2                      dout <<=1;
  79   2                      ad_clock = 0;
  80   2                      _nop_();
  81   2              }
  82   1              for(i=0;i<16;i++)
  83   1              {
  84   2                      
  85   2                      if(ad_out == 1)din |= 0x0001;
  86   2                      ad_clock = 1;
  87   2                      din <<= 1;
  88   2                      ad_clock = 0;
  89   2                      _nop_();
  90   2              }
  91   1              ad_cs = 1;
  92   1              din >>= 4;
  93   1              return (din);
  94   1      }
  95          
  96          
  97          
  98          /************费尔曼滤波*****************
  99          double KalmanFilter(const double ResrcData,
 100                                                  double ProcessNiose_Q,
 101                                                  double MeasureNoise_R)
 102          {
 103          double R = MeasureNoise_R;
 104          double Q = ProcessNiose_Q;
 105              static double x_last;
 106              double x_mid = x_last;
 107              double x_now;
 108              static double p_last;
 109              double p_mid ;
 110              double p_now;
 111              double kg;        
 112              x_mid=x_last; //x_last=x(k-1|k-1),x_mid=x(k|k-1)
 113              p_mid=p_last+Q; //p_mid=p(k|k-1),p_last=p(k-1|k-1),Q=??
 114              kg=p_mid/(p_mid+R); //kg?kalman filter,R???
 115              x_now=x_mid+kg*(ResrcData-x_mid);
 116                      
 117              p_now=(1-kg)*p_mid;  
C51 COMPILER V9.00   TLC2543                                                               07/29/2016 10:33:52 PAGE 3   

 118              p_last = p_now; 
 119              x_last = x_now; 
 120              return x_now;
 121          }
 122          */
 123          
 124          /******************冒泡排序****************************/
 125          void bubble(unsigned int* array,uchar len)
 126          {
 127   1              uchar i = 0,j = 0;
 128   1              unsigned int tmp;
 129   1              for(i = 0;i < len;i++)
 130   1                  {
 131   2                      for(j=0;j < len;j++)
 132   2                      {
 133   3                          if(array[j] > array[i])
 134   3                          {
 135   4                              tmp = array[j];
 136   4                              array[j] = array[i];
 137   4                              array[i] = tmp;
 138   4                          }
 139   3                      } 
 140   2                  }
 141   1      }
 142          
 143          /*******************计算平均值*******************************************/
 144          double Average(unsigned int *array,unsigned char index,unsigned char len)
 145          {
 146   1        double aver=0,count=index;
 147   1       int i;
 148   1       for(i=index;i<(len-index);i++)
 149   1       {
 150   2         aver+=array[i]; 
 151   2        aver/=(double)(count++==index?1:2); 
 152   2       }
 153   1       return aver;
 154   1      }
 155          
 156          /****************12864显示结果********************/
 157          void ad_show()
 158          {
 159   1      
 160   1              /**********************输入电压**********************************/
 161   1                      lcd_putnumstr(32,0,0,AD_num[0]/10000);
 162   1                      Lcd12864_Write16CnCHAR(40,0,0,".");
 163   1                      lcd_putnumstr(48,0,0,AD_num[0]%10000/1000);
 164   1                      lcd_putnumstr(56,0,0,AD_num[0]%10000%1000/100);
 165   1      //              lcd_putnumstr(64,0,0,AD_num[0]%10000%1000%100/10);
 166   1      //              lcd_putnumstr(72,0,0,AD_num[0]%10000%1000%100%10);
 167   1      
 168   1          /******************************过流保护****************************/
 169   1                                      lcd_putnumstr(104,0,0,ocp/10);
 170   1                      Lcd12864_Write16CnCHAR(112,0,0,".");
 171   1                      lcd_putnumstr(120,0,0,ocp%10);
 172   1      //              lcd_putnumstr(120,0,0,AD_num[1]%10000%1000/100);
 173   1      //              lcd_putnumstr(112,0,0,AD_num[1]%10000%1000%100/10);
 174   1      //              lcd_putnumstr(120,0,0,AD_num[1]%10000%1000%100%10);
 175   1      
 176   1          /******************************输出电压****************************/
 177   1                                      lcd_putnumstr(40,2,0,AD_num[2]/10000);
 178   1                      Lcd12864_Write16CnCHAR(48,2,0,".");
 179   1                      lcd_putnumstr(56,2,0,AD_num[2]%10000/1000);
C51 COMPILER V9.00   TLC2543                                                               07/29/2016 10:33:52 PAGE 4   

 180   1                      lcd_putnumstr(64,2,0,AD_num[2]%10000%1000/100);
 181   1      //              lcd_putnumstr(64,2,0,AD_num[2]%10000%1000%100/10);
 182   1      //              lcd_putnumstr(72,2,0,AD_num[2]%10000%1000%100%10);
 183   1      
 184   1          /******************************输出电流****************************/
 185   1                                      lcd_putnumstr(40,4,0,AD_num[3]/10000);
 186   1                      Lcd12864_Write16CnCHAR(48,4,0,".");
 187   1                      lcd_putnumstr(56,4,0,AD_num[3]%10000/1000);
 188   1                      lcd_putnumstr(64,4,0,AD_num[3]%10000%1000/100);
 189   1      }
 190          
 191          uchar x9c = 0;
 192          
 193          
 194          uint xpd(double value)
 195          {
 196   1              static const Vcc = 5.15 , R1 = 524;
 197   1              double tmp = (Vcc - value)/R1;
 198   1              double R2 = value / tmp;
 199   1              return ((R2 + 50)/10);
 200   1      }
 201          
 202          uchar swit()
 203          {
 204   1              uchar te = 0xff;
 205   1              if(sw1 == 0)te=1;
 206   1              if(sw2 == 0)te=2;
 207   1              if(sw3 == 0)te=3;
 208   1              if(sw4 == 0)te=4;
 209   1              if(sw5 == 0)te=5;
 210   1              return te;
 211   1      }
 212                  
 213          
 214          void zdInit()
 215          {
 216   1              AUXR = 0x80;
 217   1              TMOD = 0x01;
 218   1              TH0 = (65536-200)/256;
 219   1              TL0 = (65536-200)%256;
 220   1              ET0 = 1;
 221   1              TR0 = 1;
 222   1              EA = 1;
 223   1      }
 224          
 225          void systemInit()
 226          {
 227   1               zdInit();
 228   1              P4SW = P44EN | P45EN | P46EN;
 229   1              ocpOff;
 230   1              x9cInit();  //
 231   1              Lcd12864_Init();
 232   1              Lcd12864_ClearScreen(0x00);//12864清屏
 233   1              Lcd12864_Write16CnCHAR(0,0,0,"inV:     OCP:");
 234   1              Lcd12864_Write16CnCHAR(0,2,0,"outV:");
 235   1              Lcd12864_Write16CnCHAR(0,4,0,"outA:");
 236   1      }
 237          
 238          void systemRun()
 239          {
 240   1        uchar test = 0,swvalue = 0;
 241   1        while(test == 0)
C51 COMPILER V9.00   TLC2543                                                               07/29/2016 10:33:52 PAGE 5   

 242   1        {
 243   2                vad_show();
*** WARNING C206 IN LINE 243 OF TLC2543.C: 'vad_show': missing function-prototype
 244   2                swvalue = swit();
 245   2                if(swvalue != 0xff)
 246   2                {
 247   3                       switch(swvalue)
 248   3                       {
 249   4                               case 1 : break;
 250   4                               case 2 : if(ocp < 40)ocp += 1; break;
 251   4                               case 3 : ocp = 30;break;
 252   4                               case 4 : if(ocp > 5)ocp -= 1;break;
 253   4                               case 5 : break;
 254   4                               
 255   4                       }
 256   3                       delay(5000);
 257   3                       while(swit() != 0xff);
 258   3                }
 259   2        }
 260   1      
 261   1      }
 262          
 263          
 264          void zd1() interrupt 1
 265          {
 266   1              unsigned char i=0;
 267   1              TH0 = (65536-200)/256;
 268   1              TL0 = (65536-200)%256;
 269   1              e++;
 270   1              adtime++;
 271   1              if(adtime == 10)//2.0ms 采样一次  分别四路
 272   1              {
 273   2                      adtime = 0;
 274   2                      AD_[ad_chunnel][aps] = readAD(ad_chunnel);
 275   2                      ad_chunnel++;
 276   2              }
 277   1              if(ad_chunnel == 5){ad_chunnel = 0;aps++;}
 278   1      
 279   1              if(aps == 10) //100ms 计算一次
 280   1              {
 281   2                      aps = 0;
 282   2                      for(i = 0;i < 5;i++) 
 283   2                      {
 284   3                              bubble(AD_[i],10);            //冒泡
 285   3                              temp[i]  = Average(AD_[i],1,9); //平均值
 286   3                              temp[i] = (temp[i] * addTcl2543) *10000;                
 287   3                      }
 288   2              }
 289   1              if(e == 1000) //1s 输出一次
 290   1              {
 291   2                      d2buff = ~d2buff;
 292   2                      LED2 = d2buff;
 293   2                      e = 0;
 294   2                      AD_num[showts] = temp[showts];
 295   2                      showts++;
 296   2                      if(showts == 5)showts=0;
 297   2              }
 298   1      }
 299          
 300          void main()
 301          {
 302   1              systemInit();
C51 COMPILER V9.00   TLC2543                                                               07/29/2016 10:33:52 PAGE 6   

 303   1              while(1)
 304   1              {
 305   2                      systemRun();
 306   2              }
 307   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2849    ----
   CONSTANT SIZE    =   1709    ----
   XDATA SIZE       =    100    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44      64
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

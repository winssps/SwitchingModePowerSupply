C51 COMPILER V9.00   TLC2543                                                               07/31/2016 15:42:36 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TLC2543
OBJECT MODULE PLACED IN TLC2543.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE TLC2543.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include"stc12c5a.h"
   2          #include"intrins.h"
   3          #include"tlc2543.h"  //ad
   4          #include"main.h"    //主要注释
   5          #include"st7565.c"  //12864
   6          
   7          #include "x9103.c"
   8          
   9          sbit s1 = P1^3;
  10          sbit s2 = P1^4;
  11          sbit s3 = P1^5;
  12          sbit s4 = P1^6;
  13          sbit s5 = P1^7;
  14          
  15          
  16          /****************************************
  17          *五路AD： 分别采样10次，
  18          *IN0:输入电压、
  19          *IN1:输出电压、
  20          *IN3、IN3:输出电流（1）、
  21          *IN4:负载识别     电阻
  22          ********************************************/
  23          unsigned int xdata AD_[5][10] = 0;
  24          double temp[5] = 0;
  25          uint  AD_num[5]=0,e = 0;
  26          uchar aps=0,adtime=0,ad_chunnel = 0,showts = 0;
  27          
  28          uchar ocp = 30;//过流保护  一次0.1
  29          
  30          bit d2buff = 0,ocpbuff = 0,load = 0;
  31          
  32          void delay(uint t)
  33          {
  34   1              while(t--);
  35   1      }
  36          
  37          /*  硬件SPI
  38          void InitSPI()
  39          {
  40                  AUXR1 = 0X00;
  41              SPDAT = 0;      //initial SPI data
  42              SPSTAT = SPIF | WCOL;    //SPI状态寄存器
  43              SPCTL = SPEN | MSTR | SPSPEEDH;        //SPI控制寄存器
  44          }
  45          uchar WriteByte(uchar temp)
  46          {
  47          //      SPCTL = SPEN | MSTR | SPSPEEDH;        //SPI控制寄存器
  48                  SPDAT = temp;
  49              while (!(SPSTAT & SPIF));   //wait send complete
  50              SPSTAT = SPIF | WCOL;       //spi状态寄存器
  51                  delay(20);
  52                  return SPDAT;
  53          }
  54          */
  55          /*
C51 COMPILER V9.00   TLC2543                                                               07/31/2016 15:42:36 PAGE 2   

  56          uint revAD(uchar chunnel)
  57          {
  58                  uint doc = 0 , a = 0, b = 0;
  59                  ad_cs = 0;
  60                  a = WriteByte( (chunnel<<4) | 0x0c );
  61                  b = WriteByte(0);
  62                  ad_cs = 1;
  63                  a <<= 8;
  64                  doc = a | b;
  65                  doc >>= 4;
  66                  return doc;
  67          }*/
  68          
  69          /*************软件模拟SPI*****************************/
  70          uint readAD(uchar chunnel)
  71          {
  72   1              uchar i = 0,dout = ad_chunnel_select[chunnel];
  73   1              uint din=0;
  74   1              _nop_();
  75   1              _nop_();
  76   1              _nop_();
  77   1              ad_cs = 0;
  78   1      //      ad_clock = 0;
  79   1      
  80   1              for(i = 0;i < 16;i++)
  81   1              {
  82   2                      ad_clock = 1;
  83   2                      if(dout & 0x80)ad_in = 1;
  84   2                      else ad_in = 0;
  85   2                      dout <<=1;
  86   2                      ad_clock = 0;
  87   2                      _nop_();
  88   2              }
  89   1              for(i=0;i<16;i++)
  90   1              {
  91   2                      
  92   2                      if(ad_out == 1)din |= 0x0001;
  93   2                      ad_clock = 1;
  94   2                      din <<= 1;
  95   2                      ad_clock = 0;
  96   2                      _nop_();
  97   2              }
  98   1              ad_cs = 1;
  99   1              din >>= 4;
 100   1              return (din);
 101   1      }
 102          
 103          
 104          
 105          /************费尔曼滤波*****************
 106          double KalmanFilter(const double ResrcData,
 107                                                  double ProcessNiose_Q,
 108                                                  double MeasureNoise_R)
 109          {
 110          double R = MeasureNoise_R;
 111          double Q = ProcessNiose_Q;
 112              static double x_last;
 113              double x_mid = x_last;
 114              double x_now;
 115              static double p_last;
 116              double p_mid ;
 117              double p_now;
C51 COMPILER V9.00   TLC2543                                                               07/31/2016 15:42:36 PAGE 3   

 118              double kg;        
 119              x_mid=x_last; //x_last=x(k-1|k-1),x_mid=x(k|k-1)
 120              p_mid=p_last+Q; //p_mid=p(k|k-1),p_last=p(k-1|k-1),Q=??
 121              kg=p_mid/(p_mid+R); //kg?kalman filter,R???
 122              x_now=x_mid+kg*(ResrcData-x_mid);
 123                      
 124              p_now=(1-kg)*p_mid;  
 125              p_last = p_now; 
 126              x_last = x_now; 
 127              return x_now;
 128          }
 129          */
 130          
 131          /******************冒泡排序****************************/
 132          void bubble(unsigned int* array,uchar len)
 133          {
 134   1              uchar i = 0,j = 0;
 135   1              unsigned int tmp;
 136   1              for(i = 0;i < len;i++)
 137   1                  {
 138   2                      for(j=0;j < len;j++)
 139   2                      {
 140   3                          if(array[j] > array[i])
 141   3                          {
 142   4                              tmp = array[j];
 143   4                              array[j] = array[i];
 144   4                              array[i] = tmp;
 145   4                          }
 146   3                      } 
 147   2                  }
 148   1      }
 149          
 150          /*******************计算平均值*******************************************/
 151          double Average(unsigned int *array,unsigned char index,unsigned char len)
 152          {
 153   1        double aver=0,count=index;
 154   1       int i;
 155   1       for(i=index;i<(len-index);i++)
 156   1       {
 157   2         aver+=array[i]; 
 158   2        aver/=(double)(count++==index?1:2); 
 159   2       }
 160   1       return aver;
 161   1      }
 162          
 163          /****************12864显示结果********************/
 164          void ad_show()
 165          {
 166   1      
 167   1              /**********************输入电压**********************************/
 168   1                      lcd_putnumstr(64,0,0,AD_num[0]/10000);
 169   1                      lcd_putnumstr(72,0,0,AD_num[0]%10000/1000);
 170   1                      Lcd12864_Write16CnCHAR(80,0,0,".");
 171   1                      lcd_putnumstr(88,0,0,AD_num[0]%10000%1000/100);
 172   1                      lcd_putnumstr(96,0,0,AD_num[0]%10000%1000%100/10);
 173   1      
 174   1          /******************************输出电流****************************/
 175   1                      lcd_putnumstr(64,2,0,AD_num[1]/1000);
 176   1                      Lcd12864_Write16CnCHAR(72,2,0,".");
 177   1                      lcd_putnumstr(80,2,0,AD_num[1]%1000/100);
 178   1                      lcd_putnumstr(88,2,0,AD_num[1]%1000%100/10);
 179   1      
C51 COMPILER V9.00   TLC2543                                                               07/31/2016 15:42:36 PAGE 4   

 180   1          /******************************输出电压****************************/
 181   1                      lcd_putnumstr(64,4,0,AD_num[3]/1000);
 182   1                      Lcd12864_Write16CnCHAR(72,4,0,".");
 183   1                      lcd_putnumstr(80,4,0,AD_num[3]%1000/100);
 184   1                      lcd_putnumstr(88,4,0,AD_num[3]%1000%100/10);
 185   1      
 186   1                      if(load)
 187   1                      {
 188   2                              
 189   2                              lcd_putnumstr(40,6,0,ocp/10);
 190   2                              Lcd12864_Write16CnCHAR(48,6,0,".");
 191   2                              lcd_putnumstr(56,6,0,ocp%10);
 192   2      
 193   2                              lcd_putnumstr(88,6,0,AD_num[4]/1000);
 194   2                              lcd_putnumstr(96,6,0,AD_num[4]%1000/100);
 195   2                              lcd_putnumstr(104,6,0,AD_num[4]%1000%100/10);
 196   2                              lcd_putnumstr(112,6,0,AD_num[4]%1000%100%10);
 197   2                      }
 198   1                      else if(!load) 
 199   1                      {
 200   2          /******************************过流保护****************************/
 201   2                              
 202   2                              lcd_putnumstr(56,6,0,ocp/10);
 203   2                              Lcd12864_Write16CnCHAR(64,6,0,".");
 204   2                              lcd_putnumstr(72,6,0,ocp%10);   
 205   2                      }
 206   1      }
 207          
 208          uchar x9c = 0;
 209          
 210          
 211          double JRvalue(double value)
 212          {
 213   1              double Iz = value / 1000.0;
 214   1              double Jr = (3.00 - value)/Iz;
 215   1              return Jr;
 216   1      }                                                  
 217                  
 218          
 219          uchar swit()
 220          {
 221   1              uchar te = 0xff;
 222   1              if(sw1 == 0)te=1;
 223   1              if(sw2 == 0)te=2;
 224   1              if(sw3 == 0)te=3;
 225   1              if(sw4 == 0)te=4;
 226   1              if(sw5 == 0)te=5;
 227   1              return te;
 228   1      }
 229                  
 230          
 231          void zdInit()
 232          {
 233   1              AUXR = 0x80;
 234   1              TMOD = 0x01;
 235   1              TH0 = (65536-200)/256;
 236   1              TL0 = (65536-200)%256;
 237   1              ET0 = 1;
 238   1              TR0 = 1;
 239   1              EA = 1;
 240   1      }
 241          
C51 COMPILER V9.00   TLC2543                                                               07/31/2016 15:42:36 PAGE 5   

 242          void systemInit()
 243          {
 244   1              zdInit();
 245   1              P4SW = 0x70;
 246   1      //      x9cInit();  //
 247   1              Lcd12864_Init();
 248   1              Lcd12864_ClearScreen(0x00);//12864清屏
 249   1              Lcd12864_Write16CnCHAR(0,0,0,"Uin  :        V");
 250   1              Lcd12864_Write16CnCHAR(0,2,0,"Iout :        A");
 251   1              Lcd12864_Write16CnCHAR(0,4,0,"Uout :        V");
 252   1              ocpOff;
 253   1      }
 254          
 255          void systemRun()
 256          {
 257   1        uchar test = 0,swvalue = 0;
 258   1        Lcd12864_Write16CnCHAR(0,6,0,"OCP  :      ");
 259   1        while(test == 0)
 260   1        {
 261   2                ad_show();
 262   2                swvalue = swit();
 263   2                if(swvalue != 0xff)
 264   2                {
 265   3                       switch(swvalue)
 266   3                       {
 267   4                               case 1 : x9cc(1,0,1);break;
 268   4                               case 2 : x9cc(1,1,1);break;
 269   4                               case 3 : if(ocp < 40)ocp += 1;x9cc(0,0,1);break;
 270   4                               case 4 : if(ocp > 5)ocp -= 1;x9cc(0,1,1);break;
 271   4                               case 5 : 
 272   4                                              load = ~load;LED2 = 1;
 273   4                                              Lcd12864_Write16CnCHAR(0,6,0,"               ");
 274   4                                              Lcd12864_Write16CnCHAR(0,6,0,"OCP:     R:   ");
 275   4                                              test = 1;
 276   4                                                      break;
 277   4                                              default:break;
 278   4                               
 279   4                       }
 280   3                       delay(5000);
 281   3                       while(swit() != 0xff);
 282   3                }     
 283   2        }
 284   1        while(test == 1)
 285   1        {
 286   2                ad_show();
 287   2                swvalue = swit();
 288   2                if(swvalue != 0xff)
 289   2                {
 290   3                       switch(swvalue)
 291   3                       {
 292   4                               case 1 : break;
 293   4                               case 2 :  break;
 294   4                               case 3 : if(ocp < 40)ocp += 1;;break;
 295   4                               case 4 : if(ocp > 5)ocp -= 1;break;
 296   4                               case 5 : 
 297   4                                              load = ~load;LED2 = 1;
 298   4                                              Lcd12864_Write16CnCHAR(0,6,0,"               ");
 299   4                                              Lcd12864_Write16CnCHAR(0,6,0,"OCP  :      ");
 300   4                                              test = 0;
 301   4                                                      break;
 302   4                                              default:break;
 303   4                               
C51 COMPILER V9.00   TLC2543                                                               07/31/2016 15:42:36 PAGE 6   

 304   4                       }
 305   3                       delay(5000);
 306   3                       while(swit() != 0xff);
 307   3                }     
 308   2        }
 309   1      
 310   1      }
 311          
 312          uchar sw()
 313          {
 314   1              uchar te = 0xff;
 315   1              if(s1 == 0)te = 1;
 316   1              if(s2 == 0)te = 2;
 317   1              if(s3 == 0)te = 3;
 318   1              if(s4 == 0)te = 4;
 319   1              return te;
 320   1      }
 321          
 322          
 323          void zd1() interrupt 1
 324          {
 325   1              unsigned char i=0;
 326   1              TH0 = (65536-200)/256;
 327   1              TL0 = (65536-200)%256;
 328   1              e++;
 329   1              adtime++;
 330   1              if(adtime == 10)//2.0ms 采样一次  分别四路
 331   1              {
 332   2                      adtime = 0;
 333   2                      AD_[ad_chunnel][aps] = readAD(ad_chunnel);
 334   2                      ad_chunnel++;
 335   2              }
 336   1              if(ad_chunnel == 5){ad_chunnel = 0;aps++;}
 337   1      
 338   1              if(aps == 10) //100ms 计算一次
 339   1              {
 340   2                      aps = 0;
 341   2                      for(i = 0;i < 5;i++) 
 342   2                      {
 343   3                              bubble(AD_[i],10);            //冒泡
 344   3                              temp[i]  = Average(AD_[i],1,9); //平均值
 345   3                                              //输入电压
 346   3                               if(i == 0){temp[i] = ((temp[i] * 6.0) * addTcl2543) *1000;}
 347   3                               else if(i == 1){temp[i] = (((temp[i] * 2.0) * addTcl2543) *1000.0);}
 348   3                               else if(i == 3){temp[i] = (((temp[i] * 2.0) * addTcl2543) *1000.0);}
 349   3                               else if(i == 4) {
 350   4                                      temp[i] = (temp[i] * addTcl2543);
 351   4                                      temp[i] = JRvalue(temp[i]);
 352   4                                      }                       
 353   3                      }
 354   2              }
 355   1              if(e == 5000) //1s 输出一次
 356   1              {
 357   2                      d2buff = ~d2buff;
 358   2                      if(!load)LED2 = d2buff;
 359   2                      e = 0;
 360   2                      AD_num[showts] = temp[showts];
 361   2                      showts++;
 362   2                      if(showts == 5)showts=0;
 363   2              }
 364   1      }
 365          
C51 COMPILER V9.00   TLC2543                                                               07/31/2016 15:42:36 PAGE 7   

 366          void main()
 367          {
 368   1              systemInit();
 369   1      //      x9cInit();  //      
 370   1              while(1)
 371   1              {
 372   2                              
 373   2                      systemRun();
 374   2              //      ad_show();
 375   2              }
 376   1      }
 377          
 378          
 379          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3491    ----
   CONSTANT SIZE    =   1775    ----
   XDATA SIZE       =    100    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      65
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
